= Strategic Domain-Driven Design

*Domain-Driven Design* (DDD) has been around since *Eric Evans* published his book about the subject in 2003. I myself came into contact with DDD some years ago when I joined a project that suffered from data consistency problems. Duplicates showed up in the database, some information was not saved at all and you could run into optimistic locking errors anywhere and anytime. We managed to solve this by using the building blocks of tactical domain-driven design.

I have learned more about domain-driven design since then and also try use it in my projects wherever appropriate. However, during the past years when I have talked to other developers many of them have heard about the term domain-driven design but they do not know what it actually means. In this article, I am going to give a brief introduction to domain-driven design as I see and understand it. You will not become an expert in domain-driven design by reading the article, but I hope it will inspire you to read more about it elsewhere. In the last section I have some pointers to further reading that I encourage you to check out. 

Now let's get started.

== What is a Domain?

If I look up the word _domain_ in the Dictionary app on my MacBook, I get the following definition:

[quote, "Apple Dictionary"]
""
[A]n area of territory owned or controlled by a particular ruler or government... 

* a specified sphere of activity or knowledge...
""

In the case of domain-driven design, it is the second part of the definition that we are interested in. In this case, _activity_ is whatever an organization does and _knowledge_ is how the organization does it. We are also going to add the _environment_ in which the organization conducts its activities to the domain concept.

=== Subdomains

The domain concept is very broad and abstract. To make it more concrete and tangiable, it makes sense to split it up into smaller parts called _subdomains_. Finding these subdomains is not always an easy thing to do and if you get them wrong you can run into trouble down the road when the pieces in your puzzle all of a sudden do not fit well together.

Before you go looking for subdomains you should think about the subdomain categories. All subdomains can be divided into three categories:

1. Core domains
2. Supporting subdomains
3. Generic subdomains

No only will these categories help you to find your subdomains, they will also help you to prioritize your development efforts.

A *core domain* is what makes an organization special and different from other organizations. An organization cannot succeed (or even exist) without being exceptionally good in their core domain. Because the core domain is so important, it should receive the highest priority, the biggest effort and the best developers. For smaller domains you may only identify a single core domain, larger domains may have more than one. You should be prepared to implement the features of the core domain from scratch.

A *supporting subdomain* is a subdomain that is necessary for the organization to succeed, but it does not fall into the core domain category. It is not generic either because it still requires some level of specialization for the organization in question. You may be able to start with an existing solution and tweak it or extend it to your specific needs.

A *generic subdomain* is a subdomain that does not contain anything special to the organization, but is still needed for the overall solution to work. You can save a lot of time and work by trying to use off-the-shelf software for your generic subdomains. A typical example would be user identity management.

It is worth noting that the same subdomain can fall into different categories depending on what the organization does. For a company that specializes in identity management, identity management is a core domain. However, for a company that specializes in customer relations management, identity management is a generic subdomain.

Finally it is worth pointing out that all subdomains are important to the overall solution regardless of which category they fall in. They do, however, require different amounts of effort and may also have different requirements of quality and completeness.

==== Example

TODO Give an example of different subdomains

== From Problems to Solutions

You sometimes find the domain referred to as the "problem domain". This comes from the fact that the domain defines problems that the software is going to solve (after all, there is a reason why the software is being made in the first place). In his book *Implementing Domain-Driven Design*, *Vaughn Vernon* splits a domain up into a _problem space_ and a _solution space_. The problem space concentrates on what _business problems_ we are trying to solve. The subdomains belong to this space.

The solution space concentrates on _how_ the problems in the problem space are going to be solved. It is more concrete, more technical and contains more details. So how are we going to transform our problems into solutions?

== The Ubiquitous Language

To be able to create software for a domain, you need a way of describing the domain. Having a relational data model or something similar is not enough. You need to be able to not only describe things and their relations but also the dynamics such as events, processes, business invariants, how things change over time, and so on. You need to be able to discuss and reason about the domain with both your fellow developers and also the domain experts. What you need is a _ubiquitous language_.

The ubiquitous language is a language that is consistently used by both domain experts and developers to describe and discuss the domain. Apart from the code itself, this language is the most important deliverable of a domain driven design process. A big part of the language is domain terminology already being used by domain experts, but you may also need to invent new concepts and processes in cooperation with the domain experts. Because of this, *active particpation* from the domain experts is absolutely essential for domain driven design to succeed. If the customer is not intereted in putting in the time and effort to teach your their domain and help you create a ubiquitous language, you should either try to convince the customer to change their mind or pick another design method.

You can document the ubiquoitus language in various ways. A good starting point is to create a glossary of terms. Business processes can be described graphically using e.g. swimlane diagrams and flow charts. UML can be used to describe the relationship between things and state diagrams to describe how state changes as differnet things move through different processes. The subdomains are also a part of the ubiquitous language and you may even need to define different "dialects" of the language for different subdomains. This embodiment of the ubiquitous language is the *domain model* and it will eventually be transformed into working code. In other words, the domain model is _not_ the same as a data model or a UML class diagram.

The ubiquitous language has a nice feature and that is that it tells you whether you are on the right track or not. If you can easily explain a business concept or process using the language, it means you are on the right track. If you, on the other hand, find your self struggeling to explain something, you are most likely missing something from the language and thereby also from your domain model. When this happens you should grab a domain expert and go looking for the missing pieces. You may even stumble upon a revelation that turns your existing model completely upside-down and results in a far superiour domain model than you had before.

== Introducing Bounded Contexts

In a perfect world, there would be only one ubiqitous language and one model that would explain everything about a single domain. Unfortunately this is not the case, save for very small and simple domains. Business processes may overlap or even conflict. The same word may mean different things or different words may mean the same thing in different contexts. There may be (and often are) more than one way to solve a problem in the problem space, depending on how you view it.

Instead of trying to find the Big Unified Model, we choose to accept the facts and instead introduce something called *bounded contexts*. A bounded context is a distinct part of the domain in which *a particular subset or dialect of the ubiquitous language is consistent at all times*. In other words, we are applying divide and conquer and splitting the domain model up into smaller, more or less independent models with clearly defined boundaries. Every bounded context has its own name and this name is a part of the ubiquitous language.

There is not necessarily a one-to-one mapping between bounded contexts and subdomains. Since a bounded context belongs to the solution space and a subdomain to the problem space, you should think about the bounded context as one alternative solution among many possible solutions. Thus a single subdomain can contain multiple bounded contexts. You may also find yourself in a situation where a single bounded context spans multiple subdomains. There is no rule against this, but it is an indication that you may need to rethinkg your subdomains or context boundaries.

Personally I like to think about bounded contexts as separate systems (e.g. separate executable JARs or deployable WARs in the Java world). A perfect real-world exampe of this is _micro-services_, where each micro-service can be considered its own bounded context. However, this does not mean you have to implement all your bounded contexts as micro-services. A bounded context could also be a separate subsystem inside a single monolithic system.

=== Example

TODO Example of bounded contexts

== Relationships between Contexts

TODO

== Context Maps and Integration Patterns

TODO

=== Partnership

TODO

=== Shared Kernel

TODO

=== Customer-Supplier

TODO

=== Conformist

TODO

=== Anticorruption Layer

TODO

=== Open Host Service

TODO

=== Published Language

TODO

=== Separate Ways

TODO

== Why is Strategic Domain-Driven Design Important?

TODO

== Next: Tactical Domain-Driven Design

In the next section, we are going to look at tactical domain-driven design. You will learn about the building blocks you can use to transform your bounded contexts into implementable designs. These building blocks will also aid you in creating the domain model and the ubiquitous langauge.
