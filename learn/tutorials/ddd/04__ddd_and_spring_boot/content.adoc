= Domain-Driven Design, Spring Boot and Hibernate

:title: Domain-Driven Design and Spring Boot
:type: text
:author: Petter Holmsr√∂m
:tags: Domain-Driven Design, Java, Backend, Architecture, Spring Boot
:description: Learn how to use Spring Boot and Hibernate to build hexagonal, domain-driven applications
:repo:
:linkattrs:
:imagesdir: ./images

TODO Intro. prerequisites. nullability annotations.

== Why Spring Boot?

TODO Explain why choosing Spring Boot for your domain-driven project is a good choice

== Why Hibernate?

TODO Explain why Hibernate is used in this article

== Structuring Your Project

Before you get started on your Spring Boot DDD project, you should spend some time thinking about how to set it up. How you do it depends on the size of your project, but here are a few rules of thumb to get you started. 

1. You should not have more than one bounded context inside a single project. For large contexts, you can split the project up into smaller subprojects. 
2. Follow the guidelines for domain modules (see part two of this article series about tactical DDD) when you set up your package structure.
3. Just by looking at the package hierarchy you should be able to identify that this is a hexagonal DDD project.
4. Set up your packages so that you can't accidentally pick up too much if you use the `@ComponentScan` annotation. As the project grows, you will need more finegrained control of the Spring configuration of your application. This also helps making your integration tests faster. For example, if you are running tests on the domain model there is no need to bring in all the ports and adapters.
5. Create custom `@Component` annotations that explain what your Spring beans actually are in terms of the hexagonal architecture. For example, instead of just using the built in `@Service` annotation you can introduce your own `@ApplicationService` and `@DomainService` annotations. In addition to acting as documentation, this also makes it easier to write automatic tests for your architecture, for example using https://www.archunit.org/:[ArchUnit].

We are now going to look at an example to further illustrate these rules in practice.

=== Example: An Alerting System

We are now going to look at a fictional system from a domain that is very close to me personally: the emergency services (I have been an active member of the local voluntary fire department since I was ten years old and at the time of writing I am serving as the chief of said department). Let's say we are building a new dispatch- and alerting system. Our task is to design and build the alerting context, i.e. the part of the system that receives dispatch orders from the dispatch system and sends out the alerts to the resources (fire trucks, ambulances, etc.) on the field. We already know the system will be build using Spring Boot, Hibernate and a relational database.

The hexagonal architecture looks like this:

image:alerting_architecture.png[The architecture of the alerting system]

As you can see, the system has four ports:

1. *Administration* for administering the system (adding and removing resources, modifying alert destinations, tweaking alert message formats and so on).
2. *Data Access* for storing and retrieving the data needed by the system.
3. *Dispatching* for receicing dispatch orders from the dispatch system (the system that emergency call operators use to enter details about emergencies).
4. *Alerting* for sending out alerts to resources on the field.

The system also has a set of adapters:

1. A *Web UI* that allows administrators to administer the system through the *administration* port.
2. *Spring Data* allows the system to access the database through the *data access* port.
3. A *REST Controller* that the dispatch system uses to send out dispatch orders.
4. An *SMS Gateway* that sends out alerts to resources as SMS-messages.
5. A *Push Gateway* that sends out alerts to resources as push notifications.
6. A *Tetra Gateway* that sends out alerts to resources as TETRA status- and text messages.
7. A *Command System Gateway* that sends out alerts to the command systems used by different authorities on the field.

What these gateways actually look like is out of scope of this article - we only need to know that they exist.

Now let's have a quick look at the domain model. We have the following aggregates:

1. *Dispatch Order* is a dispatch order received from the dispatch system.
2. *Resource* is a particular resource that the dispatch order wants us to alert.
3. *Alert Destination* is a destination to which we should send the alert message in order to alert a specific resource. One resource can have more than one alert destination and alert destinations can also be shared by multiple resources. There can be different types of alert destinations, ranging from TETRA device numbers and GSM phone numbers to usernames and device IDs.
4. *Alert* is an alert that has been sent to a set of alert destinations in response to a dispatch order.
5. *Alert Acknowledgement* is an acknowledgment recieved by an alert destination in response to an alert. This allows us to be sure the alert has reached its destination.

With this information, we can now sketch up the following package hierarchy, sticking to the rules of thumb:

* `foo.bar.main` - the Spring Boot main application class and configurations for setting everything up.
* `foo.bar.domain.base` - Base classes, interfaces and annotations for the domain model.
* `foo.bar.domain.infrastructure` - Helper classes that may be needed to e.g. distribute domain events in a reliable way.
* `foo.bar.domain.model.dispatchorder` - Domain objects for the *Dispatch Order* aggregate.
* `foo.bar.domain.model.resource` - Domain objects for the *Resource* aggregate.
* `foo.bar.domain.model.alertdestination` - Domain objects for the *Alert Destination* aggregate.
* `foo.bar.domain.model.alert` - Domain objects for the *Alert* aggregate.
* `foo.bar.domain.model.alertacknowledgement` - Domain objects for the *Alert Acknowledgement* aggregate.
* `foo.bar.application.base` - Base classes, interfaces and annotations for the application services (i.e. the ports).
* `foo.bar.application.administration` - Interfaces and classes for the *Administration* port.
* `foo.bar.application.dispatching` - Interfaces and classes for the *Dispatching* port.
* `foo.bar.application.alerting` - Interfaces and classes for the *Alerting* port.
* `foo.bar.adapter.base` - Base classes, interfaces and annotations for the adapters.
* `foo.bar.adapter.administration.webui` - Implementation of the *Web UI*.
* `foo.bar.adapter.dispatching.rest` - Implementation of the *REST Controller*.
* `foo.bar.adapter.alerting.sms` - Implementation of the *SMS Gateway*.
* `foo.bar.adapter.alerting.push` - Implementation of the *Push Gateway*.
* `foo.bar.adapter.alerting.tetra` - Implementation of the *Tetra Gateway*.
* `foo.bar.adapter.alerting.command` - Implementation of the *Command System Gateway*.

Please note that we don't have a package for the *data access* port. This is because it is handled out of the box for us by Spring Data.

It is likely that the package hierarchy will change during the development work as we learn more about the domain model, the ports and the adapters. However, this is a good starting point.

Before we carry on, we are going to split this package hierarchy up into sub-projects. There are more than one way of doing this, but here is one example (we are using Maven):

image:alerting_subprojects.png[The sub-projects of the alerting system]

In this project structure, the domain model, the adapters and the ports all have their own sub-projects. In addition, the ports have their own API sub-projects that the adapters depend on. The main sub-project will be built into an "uberjar" that contains the entire application and will be deployed to servers.

As with the package hierarchy, it is likely that the project structure is going to change as development progresses. You may end up merging some sub-projects, split up others or even introduce completely new sub-projects. However, you should always pay attention to where your dependencies point and also take into account the transitive dependencies. In the example above, you can see that each adapter can be independently changed without affecting any other parts of the system except the uberjar. Likewise, you can change your domain model without affecting the adapters as long as the ports remain the same, and so on.

== Domain Object Hierarchy

Once the package structure is in place, I often continue with the base classes and interfaces for the domain model. These will all live in the `domain.base` package.

Recall the following diagram from part two of this article series (tactical domain driven design):

image:domain_objects.png[Hierarchy of base classes and interfaces for different domain objects]

You do not have to base your domain model on a structure like this, but personally I find it helpful as it forces me to think about the rule that each domain object plays in my current bounded context (remember, that the same real-world thing may play different roles in different contexts: it may be an entity in one context, a standard type in another and a value object in a third).

The top-most interface is easy because it is just a marker interface:

.DomainObject.java
[source,java]
----
public interface DomainObject {
    // Marker interface
}
----

The value object is also just a marker interface:

.ValueObject.java
[source,java]
----
public interface ValueObject extends DomainObject {
    // Marker interface
}
----

The indentifiable domain object is a bit more interesting:

.IdentifiableDomainObject.java
[source,java]
----
public interface IdentifiableDomainObject<Id> extends DomainObject { // <1>
    @NotNull Id getIdentifier(); // <2>

    boolean hasIdentifier(); // <3>
}
----
<1> We use a generic parameter for the identifier. We are going to return to why later in this article.
<2> This method should throw an exception if the domain object does not have an ID, for example if it has not been persisted yet. I don't like methods that return null and returning an `Optional` in this case would also not be appropriate since having a null ID is the exception and not the rule. By the way, the method is intentionally named `getIdentifier` and not `getId`. We will return to why in the section about entities and aggregates.
<3> This method is provided for the rare case when you need to check whether a domain object has an ID or not and you don't want to do this by calling `getIdentifier` and catching the excpetion.

We will look at the rest of the base classes and interfaces later in the article. Keep reading!

== Value Objects

Now it is time to roll up our sleeves and have a closer look at some actual code. Value objects are among the simplest and most useful building blocks in domain-driven design, so let's start by looking at different ways of implementing value objects in a Spring Boot application. In order to do that, we are going to steal the concepts of _simple type_ and _complex type_ from the XML Schema specification. 

A simple value object is an value object that contains exactly one value of some type, such as a single string or an integer. A complex value object is a value object that contains multiple values of multiple types, such as a postal adress complete with street name, number, postal code, city, state, country and so on. 

Because we are going to persist our value objects into a relational database, we have to treat these two types differently when we implement them. However, these implementation details should not matter to the code that actually uses the value objects.

=== Simple Value Objects: Attribute Converters

Simple value objects are very easy to persist and can be truly immutable with final fields and all. In order to persist them, you have to write an `AttributeConverter` (standard JPA interface) that knows how to convert between a database column of a known type and your value object. 

Let's start with an example value object:

.EmailAddress.java
[source,java]
----
public class EmailAddress implements ValueObject { // <1>

    private final String email; // <2>

    public EmailAddress(@NotNull String email) { 
        this.email = validate(email); // <3>
    }

    @Override
    public @NotNull String toString() { // <4>
        return email;
    }

    @Override
    public boolean equals(Object o) { // <5>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EmailAddress that = (EmailAddress) o;
        return email.equals(that.email);
    }

    @Override
    public int hashCode() { // <6>
        return email.hashCode();
    }

    public static @NotNull String validate(@NotNull String email) { // <7>
        if (!isValid(email)) {
            throw new IllegalArgumentException("Invalid email: " + email);
        }
        return email;
    }

    public static boolean isValid(@NotNull String email) { // <8>
        // Validate the input string, return true or false depending on whether it is a valid e-mail address or not
    }

}
----
<1> `ValueObject` is the empty marker interface from the `domain.base` package. It is used only for documentational purposes and has no functional meaning.
<2> The string that contains the e-mail address is marked as `final`. As this is the only field in the class, it makes the class truly immutable.
<3> The input string is validated in the constructor, making it impossible to make instances of `EmailAddress` that contain invalid data.
<4> The e-mail address string is accessible through the `toString()` method. If you want to use this method for debugging purposes, you can use another getter method of your choice (I sometimes use an `unwrap()` method as simple value objects are essentially wrappers of other values).
<5> Two value objects having the same value are considered equal so we have to implement the `equals()` method accordingly.
<6> We changed `equals()` so now we have to change `hashCode()` as well.
<7> This is a static method that is used by the constructor to validate input, but it can also be used from the outside to validate strings containing e-mail addresses. This version throws an exception if the e-mail address is invalid.
<8> Another static method that validates e-mail address strings, but this one simply returns a boolean. This can also be used from the outside.

Now, the corresponding attribute converter would look like this:

.EmailAddressAttributeConverter.java
[source,java]
----
@Converter // <1>
public class EmailAddressAttributeConverter implements AttributeConverter<String, EmailAddress> { // <2>

    @Override
    @Contract("null -> null")
    public String convertToDatabaseColumn(EmailAddress attribute) {
        return attribute == null ? null : attribute.toString(); // <3>
    }

    @Override
    @Contract("null -> null")
    public EmailAddress convertToEntityAttribute(String dbData) {
        return dbData == null ? null : new EmailAddress(dbData); // <4>
    }
}
----
<1> `@Converter` is a standard JPA annotation. If you want Hibernate to automatically apply the converter to all `EmailAddress` attributes, set the `autoApply` parameter to true (in this example it is false, which is the default).
<2> `AttributeConverter` is a standard JPA interface that takes two generic parameters: the database column type and the attribute type.
<3> This method converts an `EmailAddress` to a string. Please note that the input parameter can be `null`.
<4> This method converts a string to an `EmailAddress`. Again, please note that the input parameter can be `null`.

You can store the converter either in the same package as the value object, or in a sub-package (such as `.converters`) if you want to keep your domain packages nice and clean. 

Finally, you can use this value object in your JPA entities like this:

.Contact.java
[source,java]
----
@Entity
public class Contact {

    @Convert(converter = EmailAddressAttributeConverter.class)  // <1>
    private EmailAddress emailAddress;

    // ...
}
----
<1> This annotation informs JPA/Hibernate which converter to use. Without it, Hibernate will try to store the e-mail address as a serialized POJO as opposed to a string. I you have marked your converter to be automatically applied, then no `@Convert` annotation will be needed. However, I've found that it is less error-prone to explicitly state which converter to use. I have experienced situations where the converter was supposed to be auto-applied, but for some reason was not detected by Hibernate and so the value object was persisted as a serialized POJO and the integration test passed since it used an embedded H2 database and let Hibernate generate the schema.

Now we are almost done with the simple value objects. However, there are two caveats that we have missed that may come back and bite us once we go into production. They both have to do with the database.

The first caveat has to do with the length of the database column. By default, JPA limits the lengths of all database string (`varchar`) columns to 255 characters. E-mail addreses can be 320 characters long so if a user enters an e-mail address into the system that exceeds 255 characters, you will get an exception when you try to save the value object. To fix this, you need to do the following:

1. Make sure your database column is wide enough to contain a valid e-mail address.
2. Make sure your validation method includes a length check of the input. It should not be possible to create `EmailAddress` instances that cannot be successfully persisted.

This of course applies to other string value objects as well. Depending on the use case you can either refuse to accept strings that are too long, or just silently truncate them.

The second caveat has to do with legacy data. Suppose you have an existing database with e-mail addresses that were previously handled as simple strings and you now introduce a nice, clean `EmailAddress` value object. If any of those old e-mail addresses are invalid, you will get an exception every time you try to load an entity that has an invalid e-mail address: your attribute converter uses the constructor to create new `EmailAddress` instances and that constructor validates the input. To fix this you can do any of the following:

1. Sanitize your database and fix or remove all invalid e-mail addresses.
2. Create a second constructor used only by the attribute converter that bypasses the validation and instead sets an `invalid` flag inside the value object. This makes it possible to create invalid `EmailAddress` objects for existing legacy data while forcing new e-mail addresses to be correct. The code could look something like this:

.EmailAddress.java
[source,java]
----
public class EmailAddress implements ValueObject {

    private final String email;
    private final boolean invalid; // <1>

    public EmailAddress(@NotNull String email) { 
        this(email, true);
    }

    EmailAddress(@NotNull String email, boolean validate) { // <2>
        if (validate) {
            this.email = validate(email);
            this.invalid = false;
        } else {
            this.email = email;
            this.invalid = !isValid(email);
        }
    }

    public boolean isInvalid() { // <3>
        return invalid;
    }

    // The rest of the methods omitted

}
----
<1> This boolean flag is used inside the value object only and is never stored in the database.
<2> The constructor has package visibility in this example to prevent outside code from using it (we want all new e-mail objects to be valid). However, this also requires the attribute converter to be in the same package.
<3> This flag can be passed on to UIs to indicate to the user that the e-mail address is wrong and needs to be corrected.

There! We have all the cases covered and a robust and clean strategy for implementing and persisting simple value objects. However, the underlying database technology, that in principle our value object should not need to care about at all, has already managed to sneak itself into the implementation process (even though it is not really visible in the code). This is a trade-off we have to make if we want to utilize everything that JPA and Hibernate has to offer. This trade-off will be even bigger when we start do deal with complex value objects. Let's find out how.

=== Complex Value Objects: Embeddables

Persisting a complex value object in a relational database involves mapping multiple fields to multiple database columns. In JPA, the primary tool for this is embeddable objects (annotated with the `@Embeddable` annotation). Embeddable objects can be persisted both as single fields (annotated with the `@Embedded` annotation) or as collections (annotated with the `@ElementCollection` annotation).

However, JPA imposes certain restrictions on embeddable objects that prevent them from being truly immutable. An embeddable object cannot contain any `final` fields and should have a default no-argument constructor. Still, we want to make our value objects appear and behave as if they were immutable to the outside world. How do we do that?

Let's start with the constructor, or constructors, because we are going to need two of them. The first constructor is the initializing constructor, which will be public. This constructor is the only allowed way to construct new instances of the value object in code.

The second constructor is the default constructor and it will only be used by Hibernate. It does not need to be public, so in order to prevent it from being used in code you can make it protected, package protected or even private (it works with Hibernate but e.g. IntelliJ IDEA will complain). Sometimes I also make a custom annotation, `@UsedByHibernateOnly` or similar, that I use to mark these constructors. You can then configure your IDE to ignore those constructors when looking for unused code.

As for the fields, it is pretty simple: do not mark the fields as `final`, only set your field values from within the initializing constructor and do not declare any setter methods or other methods that write to the fields. You may also have to configure your IDE to not suggest you make those fields `final`.

Finally, you need to override `equals` and `hashCode` so that they compare based on value and not based on object identity.

Here is an example of what a finished, complex value object may look like:

.PersonName.java
[source,java]
----
@Embeddable
public class PersonName implements ValueObject { // <1>

    private String firstname; // <2>
    private String middlename;
    private String lastname;

    @SuppressWarnings("unused")
    PersonName() { // <3>    
    }

    public PersonName(@NotNull String firstname, @NotNull String middlename, @NotNull String lastname) { // <4>
        this.firstname = Objects.requireNonNull(firstname);
        this.middlename = Objects.requireNonNull(middlename);
        this.lastname = Objects.requireNonNull(lastname);
    }

    public PersonName(@NotNull String firstname, @NotNull String lastname) { // <5>
        this(firstname, "", lastname);
    }

    public @NotNull String getFirstname() { // <6>
        return firstname;
    }

    public @NotNull String getMiddlename() {
        return middlename;
    }

    public @NotNull String getLastname() {
        return lastname;
    }

    @Override
    public boolean equals(Object o) { // <7>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        PersonName that = (PersonName) o;
        return firstname.equals(that.firstname)
            && middlename.equals(that.middlename)
            && lastname.equals(that.lastname);
    }

    @Override
    public int hashCode() { // <8>
        return Objects.hash(firstname, middlename, lastname);
    }
}
----
<1> We use the same `ValueObject` marker interface that we used for simple value objects.
<2> No fields are marked as `final`.
<3> The default constructor is package protected and not used by any code at all.
<4> The initializing constructor is to be used by code.
<5> If not all fields are required, make overloaded constructors or use the builder or essence pattern. Forcing the calling code to pass in null or default arguments is ugly (my personal opinion).
<6> The outside world accesses the fields from getters only. There are no setters at all.
<7> Two value objects having the same value are considered equal so we have to implement the `equals()` method accordingly.
<8> We changed `equals()` so now we have to change `hashCode()` as well.

This value object can then be used in entities like this:

.Contact.java
[source,java]
----
@Entity
public class Contact {

    @Embedded
    private PersonName name;

    // ...
}
----


The observant reader will now notice we have again missed something: the length checks with regards to the database column widths. Just as we had to deal with that for simple value objects, we have to deal with it here. I'm going to leave it as an exercise to the reader.

Speaking of databases, there are a few more things to think about when dealing with `@Embeddable` value objects: column names and nullability.

Normally, you specify the column names inside the embeddable using the `@Column` annotation. If you leave it out, the column names are derived from the field names. This may be enough for you, but in some cases you may find yoursef using the same value object in different entities, with columns that have different names. In this case, you have to rely on the `@AttributeOverride` annotation (check it out if you are not familiar with it).

Nullability has to do with how you are going to persist the state where your value object is null. For simple value objects that was easy - just store NULL in the database column. For complex value objects being stored in a collection this is also easy - just leave the value object out. For complex value objects being stored in fields, you have to check your JPA implementation.

Hibernate, by default, will write NULL to all the columns if the field is null. Likewise, when reading from the database, if all columns are NULL Hibernate will set the field to nul. This is normally fine, provided that you don't actually want to have a value object instance whose fields are all set to null. This also means that even though your value object may require one or more of its fields to be not null, the database table must allow nulls in that column or columns if the entire value object can be null.

As you can see, the underlying database and persistence technology is even more present in the implementation of our complex value objects than it was for the simple value objects. From a productivity perspective, this is in my opinion an acceptable tradeoff. It is possible to write the domain objects completely unaware of how they are persisted, but that will then require a lot more work in the repositories - work you would have to do yourself. Unless you have a really good reason, it is often not worth the effort (it is an interesting learning experience, though, so if you have the interest and the time then by all means give it a shot).

== Entities and Aggregates

Now when you know how to build value objects, it is time to move on to the object that will actually contain your value objects: entities and aggregates. JPA has its own `@Entity` concept, but it is far less restrictive than the entity concept from DDD. This is both an advantage and a disadvantage. The advantage is that it is quite easy to implement entities and aggregates with JPA. The disadvantage is that is is equally easy to do things that is not allowed in DDD. This may be especially problematic if you are working with developers that have used JPA extensively before but who are new to DDD.

Whereas value objects just implemented an empty marker interface, entities and aggregate roots will need more extensive base classes. Getting your base classes right from the start is important as it will be quite difficult to change them later, especially if your domain model has grown big. Spring Data provides some base classes out of the box that you can use if you like, so let's start by looking at them.

=== Using `Persistable`, `AbstractPersistable` and `AbstractAggregateRoot`

Spring Data provides an interface out-of-the-box called `Persistable`. This interface has two methods, one for getting the ID of the entity and another for checking whether the entity is new or persisted. If an entity implements this interface, Spring Data will use it to decide whether to call `persist` (new entities) or `merge` (persisted entities) when saving it. You are, however, not required to implement this interface. Spring Data can also use the optimistic locking version to determine whether the entity is new or not: if there is a version, it is persisted; if there is none, it is new. You need to be aware of this when you decide how you are going to generate your entity IDs.

Spring Data also provides an abstract base class that implements the `Persistable` interface: `AbstractPersistable`. It is a generic class that takes the type of the ID as its single generic parameter. The ID field is annotated with `@GeneratedValue` which means that Hibernate will try to auto-generate the ID when the entity is first persisted. The class considers entities with a non-null ID as persisted and entities with null IDs as new. Finally, it overrides `equals` and `hashCode` so that only the class and the ID are taken into account when checking for equality. This is in line with DDD - two entities are considered the same if they have the same ID.

If you are fine with using ordinary Java types (such as `Long` or `UUID`) for your entity IDs and letting Hibernate generate them for you when the entity is first persisted, then this base class is an excellent starting point for your entities and aggregate roots. But wait, there is more.

Spring Data also provides an abstract base class called `AbstractAggregateRoot`. This is a class that - you guessed it - is designed to be extended by aggregate roots. However, it does _not_ extend `AbstractPersistable` nor does it implement the `Persistable` interface. Then why would you want to use this class? Well, it provides methods that allow your aggregate to register domain events that are then published once the entity is saved. This is really useful and we will return to this subject later in this article. In practice, you often want your aggregte roots to be `Persistable` and so you often end up implementing either the methods of `AbstractAggregteRoot` or `AbstractPersistable` in your own base class. Let's have a look at how to do that next.

=== Building Your Own Base Classes

In virtually all projects that I work on, both at work and in private, I start by creating my own base classes. Most of my domain models are build from aggregate roots and value objects; I rarely use so called local entities (entities that belong to an aggregate but are not roots).

I often start with a base class called `BaseEntity` and it looks like this:

.BaseEntity.java
[source,java]
----
@MappedSuperclass // <1>
public abstract class BaseEntity<Id extends Serializable> extends AbstractPersistable<Id> implements IdentifiableDomainObject<Id> { // <2>

    @Version // <3>
    private Long version;

    public @NotNull Optional<Long> getVersion() {
        return Optional.ofNullable(version);
    }

    protected void setVersion(@Nullable version) { // <4>
        this.version = version;
    }

    @Override
    @Transient
    public @NotNull Id getIdentifier() { // <5>
        return Optional.ofNullable(getId()).orElseThrow(() -> new IllegalStateException("No ID set"));
    }

    @Override
    public boolean hasIdentifier() { // <6>
        return getId() != null;
    }
}
----
<1> Even though the class is named `BaseEntity`, it is not a JPA `@Entity` but a `@MappedSuperclass`.
<2> The `Serializable` bound comes directly from `AbstractPersistable`. Also note the use of the `IdentifiableDomainObject` interface that we declared earlier in this article.
<3> I use optimistic locking for all my entities. We will talk briefly about this in a moment.
<4> There are very view, if any, situation where you may want to set the optimistic locking version manually. However, to be on the safe side, I provide a protected method that makes this possible. I think most Java developers with some years under their belts have experienced situations where they would really have needed to set an attribute or call a method in a super class only to find that it was private.
<5> This method comes from the `IdentifiableDomainObject` interface.
<6> This method does too.

Once I have the `BaseEntity` class in place, I move on to `BaseAggregateRoot`. This is essentially a copy of Spring Data's `AbstractAggregateRoot`, but it extends `BaseEntity`:

.BaseAggregateRoot.java
[source,java]
----
@MappedSuperclass // <1>
public abstract class BaseAggregateRoot<Id extends Serializable> extends BaseEntity<Id> {

    private final @Transient List<Object> domainEvents = new ArrayList<>(); // <2>

    protected void registerEvent(@NotNull Object event) { // <3>
        domainEvents.add(Objects.requireNonNull(event));
    }

    @AfterDomainEventPublication // <4>
    protected void clearDomainEvents() {
        this.domainEvents.clear();
    }

    @DomainEvents // <5>
    protected Collection<Object> domainEvents() {
        return Collections.unmodifiableList(domainEvents);
    }
}
----
<1> This base class is also a `@MappedSuperclass`.
<2> This list will contain all domain events we want to publish when the aggregate is saved. It is `@Transient` because we don't want to store them in the database.
<3> When you want to publish a domain event from within your aggregate, you register it using this protected method. We will have a closer look at this later in this article.
<4> This is a Spring Data annotation. Spring Data will call this method after the domain events have been published.
<5> This is also a Spring Data annotation. Spring Data will call this method to get the domain events to publish.

Like I said, I rarely use local entities. However, when that need arises, I often create a `BaseLocalEntity` class that extends `BaseEntity` but does not provide any additional functionality (except, maybe a reference to the aggregate root that owns it). I will leave this as an exercise to the reader.

=== Using Value Objects as Aggregate Identifiers

TODO Explain the challenges of using value objects as aggregate IDs in Hibernate and how to solve them

=== Optimistic Locking

TODO

=== Auditing

TODO


== Publishing Domain Events

TODO Explain how to create and publish domain events

== Reacting to Domain Events

TODO Explain how to receive domain events, the challenges with using @EventListener instead of @TransactionalEventListener and how to deal with errors

== Distributing Domain Events

TODO Explain how to distribute domain events to other contexts

== Building Repositories

TODO Explain how to build repositories

== Building Domain Services

== Application Services

== Managing Transactions

== Building Adapters

== Securing Your Application

== Spring Context Configuration

== Flyway
